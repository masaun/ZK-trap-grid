{"noir_version":"1.0.0-beta.11+fd3925aaaeb76c76319f44590d135498ef41ea6c","hash":"13968650518905338938","abi":{"parameters":[{"name":"public_inputs","type":{"kind":"struct","path":"types::public_inputs::PublicInputs","fields":[{"name":"trap_commitment","type":{"kind":"field"}},{"name":"move_x","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"move_y","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_hit","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"public"},{"name":"private_inputs","type":{"kind":"struct","path":"PrivateInputs","fields":[{"name":"trap_value","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"}],"return_type":null,"error_types":{"120623371777659700":{"error_kind":"string","string":"Invalid commitment: computed commitment does not match public commitment"},"5427360537543508017":{"error_kind":"string","string":"Claimed hit/miss does not match trap value"},"8302793715486101014":{"error_kind":"string","string":"Trap value must be 0 or 1"}}},"bytecode":"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","debug_symbols":"rZndbhs5DEbfxde5EEn99lUWi8JN3SKA4QRuUmBR9N1XmuGxkwIzMMa9MRWROpEoftKM/Wv39fDl7fvnp9O35x+7T//82n05Px2PT98/H58f969Pz6fe++v3w44/P7+eD4fetXvn76Ne9ufD6XX36fR2PD7sfu6Pb1PQj5f9abKv+3P3hofd4fS12w789nQ8jNbvh+vosDxULEUfLVb0Akj5ZkIUgRC1bSGkkCAkDZsIeiXEbYQQrwTZQsjpModc0gaC9n/sBE05bCJovBIWd7Ou7Wa4puE6Xj+Mb8vjm2Uf33K9jO/N9+NlZQklASglLAJkJQfGNui7es7lI0BXUnBdg7Scr4h2M0KDXnYymC0i4jIipgKiN/M2RCsgcoibEFniBaEbc3FZiIraJoSkK+KdtP5ErNSl5chCLOeNCLsJsbqQRmmphrqEUL27LtYRN9XFKuIv1IVaveSihU0IE04rtbi8kHJ3Xawj7q+LmC4LicsIWzs3pTCLIvWaTqm3I3Rs+YxQW0SsL6Tq5QKK2+oiXW4ATVU2IXK93gFRtyGK3ouoF41oLW0bIuidCJPLfWgSy2JptbuPnHXETUfOKuL+I8ekXXKh20rLLDQQtnyzx3j3kbOOuPvIseuDv9nyU04sd9fFOuKmulhF/IW6sMrxa3F5Fknu3tR1xE2bGlYPrcvRWeTjq9i//a/949P5wwvoLvbEPOzS9JmnzzJ91k542LXpU8JsZDbap9eNzSbOphP63CXPpsymQ7rcpFP6rDSM96JuO0b6dqq6tfGq0W10f/L+7P3F+6v3t7nfgltxq3Oc2Rxn0fuT92fvL+Nhodvqts02jlX2WcexzD4uqveb90fvT+Mc6Ta7LW6r2zYOl57TMIqpW5n7k7o190f3Oy85LxX3V/e3uT8HtzL7s87+bN4f3TovZ48rHufzy84rYfYXmf3F51ecV5xXksdlj/P1FucV51XnVedV51XnVedV51XnVedV51XPX/P8Nc9fc15zXnNec15zXnNec15zngQHSnCiBKVhxERiEq5Mo9CoBDcPFt8aEciTSCbNGDERF2SBLIXgSrDnVBSyQlbIClkhK2SFrJAVskI2yAbZIBtkg2yQDbKRDSMbRjYi5Ag5kudIniN5Rk2CnCQy58icI3NOkNGUICpBVYKsBF0JwhKUJUhL0JYgLsmQM+QMOUNGYZIhZ7KRyUYmGwVygYzQBKXJJLUxatLaNAoyapMCuUCukCtkJCdoThCdoDpBdoLuBOEJyhOkJ2hPEJ+gPmnMuTHnxpxRoCBBQYOKBhUNKhrUYDQiwYngjKvQqDQgC2Q0qAJZIKNBlcSozCjIAhkNqvrBpuonmypkhYwGVSErZIWskNGgokE1P9PV/FBXg4wGFQ2qZYILwZANcmTOkTmjQY2QI2Q0qBFyhMylpmhQE+QEGQ1qgpwgo0FNkBPkBBkNKhpUbjjlilPuOOWSUzSoaFBzYVRlFGQ0qGhQi591WvysU647LZDRoKJB5crTQtVVqg4NKhpUNKiVeq7Uc4WMBrVWYlzd2pgzGlQ0qM1PJG2RYOaMBrWRjUY2mmfDQqAhNDwbFjwbFiKuRCPTKARXgiFzDxoaNO5B4x40NGjcgyaZmEJMxQWZe9DUa8PUa8OGBsd31jY0ODfGw+gUPB5Hp+CCq+Jq7hoanFxDg3NDaZgHDw3OwQlXxlVwVVzNGxHy0OAUPDQ4BUfmPDQ4uxKuQa6jUWhUGoPcxhNtJ4/vi2xocHINDc4uw9XJ0xf4P/fnp/2X48F/b/r2dnp89/PT638vePiB6uX8/Hj4+nY+jDeFydffHf4H","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"52":{"source":"use poseidon::poseidon::bn254::{hash_1, hash_2, hash_3, hash_4, hash_5, hash_6};\n\npub fn poseidon_hash_1(inputs: [Field; 1]) -> Field {\n    hash_1(inputs)\n}\n\npub fn poseidon_hash_2(inputs: [Field; 2]) -> Field {\n    hash_2(inputs)\n}\n\npub fn poseidon_hash_3(inputs: [Field; 3]) -> Field {\n    hash_3(inputs)\n}\n\npub fn poseidon_hash_4(inputs: [Field; 4]) -> Field {\n    hash_4(inputs)\n}\n\npub fn poseidon_hash_5(inputs: [Field; 5]) -> Field {\n    hash_5(inputs)\n}\n\npub fn poseidon_hash_6(inputs: [Field; 6]) -> Field {\n    hash_6(inputs)\n}","path":"/Users/unomasanori/Projects/DEMO_MVP/ã€Noirã€‘ã€Stellar Hacks - ZK Gaming ðŸŽ²ã€‘by the Feb 24 (3am JST)/ZK-gaming-in-noir-on-stellar/trap-grid/trap-grid-position-movement/src/libs/hash/poseidon/poseidon_hash.nr"},"56":{"source":"mod libs;\nmod types;\nmod tests;\n\nuse libs::{\n    hash::poseidon::poseidon_hash::{\n        poseidon_hash_1, \n        poseidon_hash_2, \n        poseidon_hash_3, \n        poseidon_hash_4,\n        poseidon_hash_5,\n        poseidon_hash_6\n    }\n};\nuse tests::{ test_main };\n\nuse types::{\n    public_inputs::PublicInputs,\n    constants::{ GRID_SIZE, NUM_CELLS, MERKLE_TREE_DEPTH }\n};\n\n// @dev - Private inputs struct\npub struct PrivateInputs {\n    trap_value: u32,  // @dev - 0 for no trap, 1 for trap\n}\n\n/**\n * @notice - Main function to verify a move in the trap grid game\n * @param public_inputs - Contains the Merkle root, move coordinates, hit/miss claim, and Merkle proof\n * @param private_inputs - Contains the actual trap value at the move coordinates (0 or 1)\n */\nfn main(\n    public_inputs: pub PublicInputs,\n    private_inputs: PrivateInputs\n) {\n    // ------------ PUBLIC INPUTS ------------- //\n    let trap_commitment: Field = public_inputs.trap_commitment;\n    let move_x: u32 = public_inputs.move_x;\n    let move_y: u32 = public_inputs.move_y;\n    let is_hit: u32 = public_inputs.is_hit;\n\n    // ------------ PRIVATE INPUTS ------------- //\n    let trap_value: u32 = private_inputs.trap_value; // @dev - Trap value at the move coordinates (0 or 1)\n\n    // 1. Constraint: Validate coordinates are within grid\n    assert(move_x >= 0);\n    assert(move_x < GRID_SIZE);\n    assert(move_y >= 0);\n    assert(move_y < GRID_SIZE);\n\n    // 2. Constraint: Ensure trap_value is boolean (0 or 1)\n    assert((trap_value == 0) | (trap_value == 1), \"Trap value must be 0 or 1\");\n\n    // 3. Constraint: Ensure claimed result matches actual trap value\n    assert(trap_value == is_hit, \"Claimed hit/miss does not match trap value\");  // @dev - \"trap_value\" is also used used for the trap_merkle_root computation as a \"leaf\" value at the subsequent line in this circuit. Thereby, this constraint can check whether a given \"is_hit\" is truly consistent with the actual trap value at the move coordinates, which is a critical constraint to ensure the integrity of the game logic. If this assertion fails, it means that the player is claiming a hit/miss that does not align with the actual trap configuration, which would be a violation of the game's rules.\n\n    // 4-1: Compute a trap commitment by hashing the trap value with the moved position index. This commitment represents the specific trap configuration at the move coordinates and will be used as the leaf value for Merkle proof verification.\n    let computed_trap_commitment = poseidon_hash_1([trap_value as Field]);\n\n    // 4-2. Constraint: Verify that the computed trap commitment matches the public trap commitment\n    assert(computed_trap_commitment == trap_commitment, \"Invalid commitment: computed commitment does not match public commitment\");\n}","path":"/Users/unomasanori/Projects/DEMO_MVP/ã€Noirã€‘ã€Stellar Hacks - ZK Gaming ðŸŽ²ã€‘by the Feb 24 (3am JST)/ZK-gaming-in-noir-on-stellar/trap-grid/trap-grid-position-movement/src/main.nr"},"67":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::poseidon::bn254::consts;\nuse crate::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/poseidon/v0.2.3/src/poseidon/bn254/perm.nr"},"68":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Creates state array with input at positions [1..N+1], then applies permutation\nfn hash_internal<let N: u32, let STATE_SIZE: u32>(\n    input: [Field; N],\n    perm_fn: fn([Field; STATE_SIZE]) -> [Field; STATE_SIZE],\n) -> Field {\n    let mut state = [0; STATE_SIZE];\n    for i in 0..N {\n        state[i + 1] = input[i];\n    }\n    perm_fn(state)[0]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    hash_internal(input, perm::x5_2)\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    hash_internal(input, perm::x5_3)\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    hash_internal(input, perm::x5_4)\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    hash_internal(input, perm::x5_5)\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    hash_internal(input, perm::x5_6)\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    hash_internal(input, perm::x5_7)\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    hash_internal(input, perm::x5_8)\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    hash_internal(input, perm::x5_9)\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    hash_internal(input, perm::x5_10)\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    hash_internal(input, perm::x5_11)\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    hash_internal(input, perm::x5_12)\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    hash_internal(input, perm::x5_13)\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    hash_internal(input, perm::x5_14)\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    hash_internal(input, perm::x5_15)\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    hash_internal(input, perm::x5_16)\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    hash_internal(input, perm::x5_17)\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/poseidon/v0.2.3/src/poseidon/bn254.nr"},"69":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse std::default::Default;\nuse std::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        std::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        std::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    std::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: u32,\n    capacity: u32,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, (rate + capacity) as Field);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n","path":"/Users/unomasanori/nargo/github.com/noir-lang/poseidon/v0.2.3/src/poseidon/mod.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}